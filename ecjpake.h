/*
 * Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the OpenSSL license (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#ifndef __ecpake_h__
#define __ecpake_h__ 1
#include <sys/cdefs.h>
__BEGIN_DECLS

#include <openssl/hmac.h>
#include <openssl/ec.h>
#include <openssl/ossl_typ.h>

#undef NDEBUG

#include <openssl/opensslv.h>
#if OPENSSL_VERSION_NUMBER < 0x10100000L
#include <openssl/libcrypto-compat.h>
#endif

#include "ecjpake_struct.h"
#include "ecjpake_zkp.h"

/**
 * Password Authenticated Key Exchange by Juggling
 * implemented with elliptic curves, based on RFC:
 * https://tools.ietf.org/html/rfc8236
 * 
 * Only the first two rounds are necessecary to generate
 * a session key.  The third round may be used to validate
 * the key generated by both parties.
 */

/**
 * Generate the first round payload containing two random points
 * (Gx1, Gx2) and zero-knowledge proofs for both.
 */
int EC_JPAKE_STEP1_generate(EC_JPAKE_STEP1 *step1, EC_JPAKE_CTX *ctx, const EVP_MD *digestMethod);

/**
 * Generate the first round payload if points have already been chosen
 * (x1, x2), generating zero-knowledge proofs for both.
 */
int EC_JPAKE_STEP1_generate_proofs(EC_JPAKE_STEP1 *step1, EC_JPAKE_CTX *ctx, const EVP_MD *digestMethod);

/**
 * Validate a peer's (Bob's) first round payload. This populates the client's (Alice's) x3 and x4.
 * This flavor does NOT check the ZKPs.
 */
int EC_JPAKE_STEP1_process_noproof(EC_JPAKE_CTX *ctx, const char *partnerParticipantId, const EC_JPAKE_STEP1 *received, const EVP_MD *digestMethod);

/**
 * Validate a peer's (Bob's) first round payload. This populates the client's (Alice's) x3 and x4.
 */
int EC_JPAKE_STEP1_process(EC_JPAKE_CTX *ctx, const char *partnerParticipantId, const EC_JPAKE_STEP1 *received, const EVP_MD *digestMethod);

/**
 * Generate the second round payload for a participant.
 */
int EC_JPAKE_STEP2_generate(EC_JPAKE_STEP2 *step2, EC_JPAKE_CTX *ctx, const EVP_MD *digestMethod);

/**
 * Validates the round two data created by our peer, without testing the proofs.
 */
int EC_JPAKE_STEP2_process_noproof(EC_JPAKE_CTX *ctx, const char *partnerParticipantId, const EC_JPAKE_STEP2 *received, const EVP_MD *digestMethod);

/**
 * Validates the round two data created by our peer.
 */
int EC_JPAKE_STEP2_process(EC_JPAKE_CTX *ctx, const char *partnerParticipantId, const EC_JPAKE_STEP2 *received, const EVP_MD *digestMethod);

/**
 * Finds the shared key between two participants.
 */
const BIGNUM *EC_JPAKE_get_shared_key(EC_JPAKE_CTX *ctx, const EVP_MD *hashMethod);

/**
 * Generates an a Hashed Message Authentication Code comprised of a key, the user Ids and EC Points
 * generated in the previous rounds.
 */
int EC_JPAKE_STEP3_generate(EC_JPAKE_CTX *ctx, EC_JPAKE_STEP3 *send, const BIGNUM *key);

/**
 * This validates the partner MacTag by calculating
 * the expected MacTag using the parameters as the partner
 * would have used when the partner called calculateMacTag.
 */
int EC_JPAKE_STEP3_process(EC_JPAKE_CTX *ctx, const char *partnerParticipantId, EC_JPAKE_STEP3 *received, const BIGNUM *key);

__END_DECLS
#endif /* __ecpake_h__ */
